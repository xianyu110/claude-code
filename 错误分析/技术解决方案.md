# 技术解决方案详细指南

## 问题诊断工具

### 1. 浏览器开发者工具检查
```javascript
// 在浏览器控制台运行，检查 CORS 问题
console.log('检查 CORS 设置:');
fetch('https://chatgpt.com/test')
  .then(response => console.log('成功:', response))
  .catch(error => console.log('CORS 错误:', error));
```

### 2. 网络请求监控
```javascript
// 监控失败的请求
const originalFetch = window.fetch;
window.fetch = function(...args) {
  console.log('请求:', args[0]);
  return originalFetch.apply(this, args)
    .then(response => {
      console.log('响应状态:', response.status);
      return response;
    })
    .catch(error => {
      console.error('请求失败:', error);
      throw error;
    });
};
```

## 解决方案实施

### 方案 1: 后端代理服务器（推荐）

#### Node.js Express 代理示例：
```javascript
const express = require('express');
const { createProxyMiddleware } = require('http-proxy-middleware');
const cors = require('cors');

const app = express();

// 启用 CORS
app.use(cors({
  origin: 'https://saas.maynor1024.live',
  credentials: true
}));

// 创建代理中间件
const chatgptProxy = createProxyMiddleware({
  target: 'https://chatgpt.com',
  changeOrigin: true,
  pathRewrite: {
    '^/api/chatgpt': ''
  },
  onProxyReq: (proxyReq, req, res) => {
    // 添加必要的头部
    proxyReq.setHeader('User-Agent', 'Mozilla/5.0...');
    proxyReq.setHeader('Origin', 'https://chatgpt.com');
  },
  onProxyRes: (proxyRes, req, res) => {
    // 修改响应头
    proxyRes.headers['Access-Control-Allow-Origin'] = 'https://saas.maynor1024.live';
  }
});

// 使用代理
app.use('/api/chatgpt', chatgptProxy);

app.listen(3001, () => {
  console.log('代理服务器运行在端口 3001');
});
```

#### 前端调用代理：
```javascript
// 原来的请求
// fetch('https://chatgpt.com/backend-api/estuary/content?id=...')

// 改为通过代理请求
fetch('/api/chatgpt/backend-api/estuary/content?id=file-NP2KtBX3E5H2yU3EAoXVPi...')
  .then(response => response.blob())
  .then(blob => {
    const imageUrl = URL.createObjectURL(blob);
    document.getElementById('image').src = imageUrl;
  })
  .catch(error => {
    console.error('图片加载失败:', error);
    // 显示默认图片
    document.getElementById('image').src = '/default-image.png';
  });
```

### 方案 2: 服务端图片缓存

#### Python Flask 示例：
```python
from flask import Flask, request, Response
from flask_cors import CORS
import requests
import os

app = Flask(__name__)
CORS(app, origins=['https://saas.maynor1024.live'])

@app.route('/proxy/image')
def proxy_image():
    image_url = request.args.get('url')
    file_id = request.args.get('id')
    
    # 检查缓存
    cache_path = f'cache/{file_id}.jpg'
    if os.path.exists(cache_path):
        with open(cache_path, 'rb') as f:
            return Response(f.read(), mimetype='image/jpeg')
    
    try:
        # 请求原始图片
        headers = {
            'User-Agent': 'Mozilla/5.0...',
            'Referer': 'https://chatgpt.com'
        }
        response = requests.get(image_url, headers=headers)
        
        if response.status_code == 200:
            # 保存到缓存
            os.makedirs('cache', exist_ok=True)
            with open(cache_path, 'wb') as f:
                f.write(response.content)
            
            return Response(response.content, mimetype='image/jpeg')
        else:
            return Response('图片加载失败', status=404)
            
    except Exception as e:
        return Response(f'错误: {str(e)}', status=500)

if __name__ == '__main__':
    app.run(debug=True, port=5000)
```

### 方案 3: 客户端错误处理和降级

#### React 组件示例：
```jsx
import React, { useState, useEffect } from 'react';

const ImageComponent = ({ imageId, fallbackSrc = '/default-image.png' }) => {
  const [imageSrc, setImageSrc] = useState(fallbackSrc);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const loadImage = async () => {
      try {
        setLoading(true);
        setError(null);
        
        // 尝试多个图片源
        const sources = [
          `/api/proxy/image?id=${imageId}`,
          `https://your-cdn.com/images/${imageId}`,
          fallbackSrc
        ];
        
        for (const src of sources) {
          try {
            const response = await fetch(src);
            if (response.ok) {
              const blob = await response.blob();
              const url = URL.createObjectURL(blob);
              setImageSrc(url);
              setLoading(false);
              return;
            }
          } catch (e) {
            console.warn(`图片源 ${src} 加载失败:`, e);
          }
        }
        
        // 所有源都失败，使用默认图片
        setImageSrc(fallbackSrc);
        setError('图片加载失败，显示默认图片');
        
      } catch (e) {
        setError('图片加载错误');
        setImageSrc(fallbackSrc);
      } finally {
        setLoading(false);
      }
    };

    if (imageId) {
      loadImage();
    }
  }, [imageId, fallbackSrc]);

  if (loading) {
    return <div className="image-loading">加载中...</div>;
  }

  return (
    <div className="image-container">
      <img 
        src={imageSrc} 
        alt="Content"
        onError={() => {
          if (imageSrc !== fallbackSrc) {
            setImageSrc(fallbackSrc);
            setError('图片显示失败，已切换到默认图片');
          }
        }}
      />
      {error && <div className="error-message">{error}</div>}
    </div>
  );
};

export default ImageComponent;
```

### 方案 4: Nginx 反向代理配置

```nginx
server {
    listen 80;
    server_name saas.maynor1024.live;
    
    # 静态文件
    location / {
        root /var/www/html;
        try_files $uri $uri/ /index.html;
    }
    
    # ChatGPT API 代理
    location /api/chatgpt/ {
        proxy_pass https://chatgpt.com/;
        proxy_set_header Host chatgpt.com;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # CORS 头部
        add_header Access-Control-Allow-Origin "https://saas.maynor1024.live";
        add_header Access-Control-Allow-Methods "GET, POST, OPTIONS";
        add_header Access-Control-Allow-Headers "Content-Type, Authorization";
        
        # 处理预检请求
        if ($request_method = 'OPTIONS') {
            add_header Access-Control-Allow-Origin "https://saas.maynor1024.live";
            add_header Access-Control-Allow-Methods "GET, POST, OPTIONS";
            add_header Access-Control-Allow-Headers "Content-Type, Authorization";
            add_header Content-Length 0;
            add_header Content-Type text/plain;
            return 204;
        }
    }
}
```

## React SSR 错误修复

### 修复 useLayoutEffect 错误：
```javascript
import { useEffect, useLayoutEffect } from 'react';

// 安全的 useLayoutEffect
const useIsomorphicLayoutEffect = 
  typeof window !== 'undefined' ? useLayoutEffect : useEffect;

// 使用示例
const MyComponent = () => {
  useIsomorphicLayoutEffect(() => {
    // 只在客户端执行的代码
    console.log('客户端特有的逻辑');
  }, []);

  return <div>我的组件</div>;
};
```

### 条件渲染避免 SSR 问题：
```javascript
import { useState, useEffect } from 'react';

const ClientOnlyComponent = ({ children }) => {
  const [hasMounted, setHasMounted] = useState(false);

  useEffect(() => {
    setHasMounted(true);
  }, []);

  if (!hasMounted) {
    return null;
  }

  return children;
};

// 使用示例
const App = () => {
  return (
    <div>
      <h1>服务端和客户端都渲染</h1>
      <ClientOnlyComponent>
        <ImageComponent imageId="file-NP2KtBX3E5H2yU3EAoXVPi" />
      </ClientOnlyComponent>
    </div>
  );
};
```

## 监控和调试工具

### 错误监控：
```javascript
// 全局错误处理
window.addEventListener('error', (event) => {
  console.error('全局错误:', event.error);
  // 发送错误报告到监控服务
});

window.addEventListener('unhandledrejection', (event) => {
  console.error('未处理的 Promise 拒绝:', event.reason);
  // 发送错误报告
});

// 网络错误监控
const observer = new PerformanceObserver((list) => {
  list.getEntries().forEach((entry) => {
    if (entry.name.includes('chatgpt.com') && entry.responseStatus >= 400) {
      console.error('ChatGPT 请求失败:', entry);
    }
  });
});
observer.observe({ entryTypes: ['resource'] });
```

## 部署检查清单

- [ ] 配置反向代理或后端代理
- [ ] 设置正确的 CORS 头部
- [ ] 实现图片缓存机制
- [ ] 添加错误处理和降级方案
- [ ] 修复 React SSR 问题
- [ ] 配置监控和日志记录
- [ ] 测试跨域请求
- [ ] 验证图片加载功能 